/// @author philogy <https://github.com/philogy>

#define function mineAngstromHookAddress(address owner) public returns (bytes32)
#define function HOOK_INITCODE_STORE() public view returns (address)

#define constant UNI_V4 = 0xc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1
#define constant DESIRED_HOOK_FLAGS = 0x25cf
#define constant HOOK_FLAGS_MASK = 0x3fff

#define macro RUNTIME() = {
    VALIDATE_SELECTOR()
    GET_CREATECODE_STORE()   // [createcode_store]
    COMPUTE_INITCODE_HASH()  // [initcode_hash]

    BATCH_MINE_AND_RETURN()  // [salt]

    simple_revert:
        0x0 0x0 revert
}

#define macro INIT_MINING() = takes(1) returns (0) {
    // entry stack:                                  [initicode_hash]
    0x40 mstore                                   // []
    caller 0x00 mstore                            // []
    0xff 0x0b mstore8                             // []
}

#define macro BATCH_MINE_AND_RETURN() = takes(1) returns (1) {
    // entry stack:                            [initicode_hash]
    INIT_MINING()                           // []
    // Set initial salt = block.number      // []
    number 0x20 mstore                      // []
    0x0                                     // [junk]
    next_mining_batch:                      // [prev_salt]
        pop                                 // []
        0x20 mload                          // [salt]
        0x1                                 // [salt, acc := 1]
        HASH18_CHUNK()                      // [salt, acc']
        0x0 lt                              // [salt, packed_acc]
        HASH18_CHUNK()                      // [salt, acc']
        0x0 lt                              // [salt, packed_acc]
        HASH18_CHUNK()                      // [salt, acc']
    // If `acc' == 0` one of the addresses in the chunk was valid.
    next_mining_batch jumpi                 // [salt]
    check_next:                             // [salt]
        0x20 mstore                         // []
        0x55 0xb sha3 dup1                  // [hash, hash]
        [DESIRED_HOOK_FLAGS] xor            // [hash, hash ^ flags]
        [HOOK_FLAGS_MASK] and               // [hash, zero_if_match]
    check_next jumpi                        // [hash]
    0x20 dup1 return                        // [...] -- Terminates execution.

}

#define macro HASH18_CHUNK() = takes(1) returns(1) {
    // takes:                                    [acc]
    // Unbounded repeated multiplication could eventually overflow falsely truncating data. We do
    // exactly 18 because the masked flag value is 14-bits so we are guaranted to still be within
    // 256-bits.
    ACC_SINGLE_HASH() ACC_SINGLE_HASH() ACC_SINGLE_HASH()
    ACC_SINGLE_HASH() ACC_SINGLE_HASH() ACC_SINGLE_HASH()
    ACC_SINGLE_HASH() ACC_SINGLE_HASH() ACC_SINGLE_HASH()
    ACC_SINGLE_HASH() ACC_SINGLE_HASH() ACC_SINGLE_HASH()
    ACC_SINGLE_HASH() ACC_SINGLE_HASH() ACC_SINGLE_HASH()
    ACC_SINGLE_HASH() ACC_SINGLE_HASH() ACC_SINGLE_HASH()
    // returns:                                  [acc']
}

#define macro ACC_SINGLE_HASH() = takes(1) returns(1) {
    // takes:                                    [acc]
    0x55 0xb sha3 dup1                        // [acc, hash, hash]       cost  = 57
    // Use hash as next salt.
    0x20 mstore                               // [acc, hash]             cost  = 6
    [DESIRED_HOOK_FLAGS] xor                  // [acc, hash ^ flags]     cost  = 6
    [HOOK_FLAGS_MASK] and                     // [acc, zero_if_match]    cost  = 6
    mul                                       // [acc']                  cost  = 5
    // returns:                                  [acc']                 total => 80
}


#define macro VALIDATE_SELECTOR() = takes(0) returns(0) {
    0x0 calldataload 0xe0 shr
    __FUNC_SIG(mineAngstromHookAddress) xor simple_revert jumpi
}

#define macro COMPUTE_INITCODE_HASH() = takes(1) returns(1) {
    // takes:                         [createcode_store]
    0x1 dup2                       // [createcode_store, 1, createcode_store]
    extcodesize sub                // [createcode_store, size := createcode_store.codesize - 1]
    0x1 0x0                        // [createcode_store, size, 1, 0]
    dup3                           // [createcode_store, size, 1, 0, size]
    swap4                          // [size, size, 1, 0, createcode_store]
    extcodecopy                    // [size]
    // Encode `(address, address)` initcode args.
    [UNI_V4] dup2 mstore           // [size]
    LOAD_INITIAL_OWNER() dup2      // [size, initial_owner, size]
    0x20 add mstore                // [size]
    0x40 add                       // [encoded_size]
    0x0 sha3                       // [initcode_hash]
}


#define macro GET_CREATECODE_STORE() = takes(0) returns(1) {
    // Encode `HOOK_INITCODE_STORE()`.
    __FUNC_SIG(HOOK_INITCODE_STORE) 0x0 mstore
    // Call `HOOK_INITCODE_STORE()` expecting encoded `(address,)` as return data.
    0x20 0x0 0x04 0x1c caller gas staticcall
    // Check call success.
    iszero simple_revert jumpi
    // Load address to stack
    0x0 mload
}

// Loads `(address)` from the encoded `mineAngstromHookAddress(address)` payload.
#define macro LOAD_INITIAL_OWNER() = takes(0) returns(1) {
    0x04 calldataload
}
